---
title: "Circleries"
author: "Vincent Somerville"
date: "02/10/2020"
output: html_document
---

```{r setup ,echo=FALSE}
knitr::opts_chunk$set(message=FALSE, echo=FALSE, eval=FALSE)
```

## Input 

Here, I start defining necessary bash variables.
```{bash}

#!/bin/bash
############################################################
# Help                                                     #
############################################################
Help()
{
   # Display Help
   echo "Circleries: checks the completness, circularity and bacterial origins of contigs and start aligns them at dnaA if possible"
   echo
   echo "Syntax: Circleries [-g|h|v|V]"
   echo "options:"
   echo "-p     circleries scirpt path" #circleriesPATH
   echo "-i     input genome name (in fasta format)" #genomeFASTAname
   echo "-d     output direcotry [.]" #outputFolderName
   echo "-t     number of threads to use [4]" #threads
   echo "-o     output file name  [results]" #threads #outName
   echo "-l     long read file" #longreads
   echo "-f     short read forward read (read 1)" #shortreads_1
   echo "-r     short read reverse read (read 2)" #shortreads_2
   echo "-h     help option" #shortreads_2

   echo
}


############################################################
############################################################
# Main program                                             #
############################################################
############################################################

# Set defaults
Name="world"
circleriesPATH=$PATH
genomeFASTAname=03_test_Data/Ldel_24754/assembly.fasta
outputFolderName=04_OUTPUTTest_02
threads=4
outName=Final_startAligned
longreads=03_test_Data/Ldel_24754/24754_filtered.fastq.gz
#shortreads_1=03_test_Data/Ldel_24754/FAM24754_R1_val_1.fq.gz
shortreads_2=03_test_Data/Ldel_24754/FAM24754_R2_val_2.fq.gz

# Set Infos
AUTHOR="Vincent Somerville"
EXE="Circleries"
VERSION="V0.0.1" 
starttime=$(date)

unset genomeFASTAname
unset shortreads_1


############################################################
# Process the input options. Add options as needed.        #
############################################################
# Get the options
#while getopts ":pidtolfrh:" option; do
while getopts ":hpi:" option; do
   case $option in
      h) # display Help
         Help
         exit;;
      p) #circleries scirpt path
         circleriesPATH=$OPTARG;;
      i) #input genome name (in fasta format)
         genomeFASTAname=$OPTARG;;
      d) #output direcotry [.]
         outputFolderName=$OPTARG;;
      f) #short read forward read (read 1)
         shortreads_1=$OPTARG;;
     \?) # Invalid option
         echo "Error: Invalid option"
         Help
         exit;;
   esac
done

# check for mandatory parameters and inputs

: ${genomeFASTAname:?Missing: "-i" which is the input genome name (in fasta format). this information is mandatory}
: ${shortreads_1:?Missing: "-f" which short read forward read (read 1). this information is mandator}

echo "hello $Name!"

```



testset

```{bash parameters, eval=TRUE}

#---------------------------------------
## testset 1
#---------------------------------------

circleriesPATH=/home/vincent/Desktop/Projects/2020_circleries
genomeFASTAname=03_test_Data/test_streptococcus_polished_dnaA-pos-1526474_nonOVERLAPING.fasta
outputFolderName=04_OUTPUTTest
threads=8
outName=Final_startAligned
longreads=
shortreads_1=
shortreads_2=

#---------------------------------------
## testset 2
#---------------------------------------
circleriesPATH=/home/vincent/Desktop/Projects/2020_circleries
genomeFASTAname=03_test_Data/Ldel_24754/assembly.fasta
outputFolderName=04_OUTPUTTest_02
threads=8
outName=Final_startAligned
longreads=03_test_Data/Ldel_24754/24754_filtered.fastq.gz
shortreads_1=03_test_Data/Ldel_24754/FAM24754_R1_val_1.fq.gz
shortreads_2=03_test_Data/Ldel_24754/FAM24754_R2_val_2.fq.gz


```

testset circular

```{bash parameters, eval=TRUE}


```

## some Info

```{bash}
# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
# welcome message

echo -e "This is "$EXE $VERSION
echo -e "Written by "$AUTHOR
echo -e "Local time is" $starttime
echo -e "Operating system is "$OSTYPE

```



## Dependencies

```{bash dependencies , eval=TRUE}


#conda activate circleries

SCRIPT_PATH=$(dirname $(realpath -s $0))

###---------------------------------
## Part 1. 
###---------------------------------

#busco

###---------------------------------
## Part 2. 
###---------------------------------

minimap2 --version
#htsbox
#bwa

###---------------------------------
## Part 3. 
###---------------------------------

fasta_shift_path=/home/vincent/Desktop/Projects/2020_circleries/02_dependencies/fasta_shift
$fasta_shift_path --help

revseq #emboss toolkit

#prodigal --version

###---------------------------------
## Part 4. 
###---------------------------------

bedtools -h

#PROKKA --version
#bwa --version


```



## 1. check if bacterial contig

#### 1.1 contig description

Here, I quickly look for the number, name and length of contigs in the file. 
Therefore I worked on a nice oneliner from [Daniel Cook](https://www.danielecook.com/generate-fasta-sequence-lengths/)

```{bash}

##================================
##header
##================================

cd ${circleriesPATH}

##================================
##create output folders
##================================

mkdir -p ${outputFolderName}
mkdir -p ${outputFolderName}/genomes
##================================
##contig length
##================================

#cat ${genomeFASTAname} | awk '$0 ~ ">" {if (NR > 1) {print c;} c=0;printf substr($0,2,100) "\t"; } $0 !~ ">" {c+=length($0);} END { print c; }' > ${outputFolderName}/genome.log
#cat ${outputFolderName}/genome.log

##================================
##change fasta sequence onto one line
##this is useful in order to easly and quickly extract one contig after enother
##here we also change the fasta header to contain no whitespaces or tabs
##================================

sed '/>/s/\t/_/g' ${genomeFASTAname}|sed '/>/s/ /_/g'|sed '/>/s/$/\t/g' | tr -d '\n' | sed 's/\t/\n/g' | sed 's/>/\n>/g' | sed '/^[[:space:]]*$/d'  > ${outputFolderName}/genomes/tmp_wide_all.fasta

##================================
##split every contig into one row
##================================

for header in $(grep ">" ${outputFolderName}/genomes/tmp_wide_all.fasta)
do

echo $header
mkdir -p  ${outputFolderName}/genomes/contigs_split/
header_short=$(echo ${header}|sed 's/>//g' )
grep "${header}" -A 1 ${outputFolderName}/genomes/tmp_wide_all.fasta > ${outputFolderName}/genomes/contigs_split/${header_short}.fasta

done
##================================
##make prodigal 
##================================

#rm -r ${outputFolderName}/genomes/annotations/
#mkdir -p ${outputFolderName}/genomes/annotations/

#prodigal -i ${outputFolderName}/genomes/tmp_wide_all.fasta -o ${outputFolderName}/genomes/annotations/prodigal_out -a ${outputFolderName}/genomes/annotations/prodigal_out_my.proteins.faa

```

  
#### 1.2 dnaA search

##### 1.2.2 sequence preperation

Here, I quickly look for the number, name and length of contigs in the file. 
Therefore I worked on a nice oneliner from [Daniel Cook](https://www.danielecook.com/generate-fasta-sequence-lengths/)

Further I check for the presence of dnaA. 
I also run a Busco to identify the bacterial contigs. 

```{bash prepperation , eval=FALSE}
##================================
##header
##================================

cd ${circleriesPATH}

##================================
##create output folders
##================================

mkdir -p ${outputFolderName}
mkdir -p ${outputFolderName}/genomes
##================================
##contig length
##================================

#cat ${genomeFASTAname} | awk '$0 ~ ">" {if (NR > 1) {print c;} c=0;printf substr($0,2,100) "\t"; } $0 !~ ">" {c+=length($0);} END { print c; }' > ${outputFolderName}/genome.log
#cat ${outputFolderName}/genome.log

##================================
##change fasta sequence onto one line
##this is useful in order to easly and quickly extract one contig after enother
##here we also change the fasta header to contain no whitespaces or tabs
##================================

#sed '/>/s/\t/_/g' ${genomeFASTAname}|sed '/>/s/ /_/g'|sed '/>/s/$/\t/g' | tr -d '\n' | sed 's/\t/\n/g' > ${outputFolderName}/genomes/tmp_wide_all.fasta

##================================
##split every contig into one row
##================================

for header in $(grep ">" ${outputFolderName}/genomes/tmp_wide_all.fasta)
do

echo $header
mkdir -p  ${outputFolderName}/genomes/contigs_split/
header_short=$(echo ${header}|sed 's/>//g' )
grep "${header}" -A 1 ${outputFolderName}/genomes/tmp_wide_all.fasta > ${outputFolderName}/genomes/contigs_split/${header_short}.fasta

done
```

##### 1.2.3 dnaA Search

```{bash MINIMAP2 , eval=FALSE}
##================================
##minimap2 ORIs to sequences
##================================

rm -r ${outputFolderName}/start_alignment_mapping/
mkdir -p ${outputFolderName}/start_alignment_mapping/

for header in $(grep ">" ${outputFolderName}/genomes/tmp_wide_all.fasta|sed 's/>//g')
do

echo $header

##map dnaA genes to the individual references and remove non-mapping or low quality mapping reads (mapq>50) 
minimap2 ${outputFolderName}/genomes/contigs_split/${header}.fasta ${circleriesPATH}/05_startAlign_data/starting_genes.fasta  |awk -F "\t" '{OFS="\t"}{if($12>50) print $0}'  > ${outputFolderName}/start_alignment_mapping/${header}.minimap


done

##================================
##minimap2 analysis
##================================

echo -e "#contigName\tContigOrigin\tNumberOfdnaAmappings\tOrientationOfMapping\tStartOfTargetMapping\tContigLength" >  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap

for header in $(grep ">" ${outputFolderName}/genomes/tmp_wide_all.fasta|sed 's/>//g')
do

echo $header


#find out if there are mappings and in which orientation
number_of_mappings=$(wc -l ${outputFolderName}/start_alignment_mapping/${header}.minimap|cut -d ' ' -f 1)
orientation=$(sort -k10 -n -r ${outputFolderName}/start_alignment_mapping/${header}.minimap|head -1 |cut -f 5)

 
# create a info table containing information about the presence of dnaA and if present the orientation

if [ $number_of_mappings == "0" ]
then
        echo "no dnaA map found"
      
       echo -e ${header}"\tnon-bacterial_contig\t"${number_of_mappings}"\tNA\tNA\tNA" >>  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap
    
elif [ $orientation == "+" ]
then
      echo "dnaA map found"
  #the most left alignment this shows the start of the gene
  #sort -k8 -n ${outputFolderName}/start_alignment_mapping/${header}.minimap

  start=$(sort -k8 -n ${outputFolderName}/start_alignment_mapping/${header}.minimap|head -1 |awk -F "\t" '{OFS="\t"}{print $8-$3-5}')
        contig_length=$(sort -k8 -n ${outputFolderName}/start_alignment_mapping/${header}.minimap|head -1 |cut -f 7)
        
        echo -e ${header}"\tbacterial_contig\t"${number_of_mappings}"\t"${orientation}"\t"${start}"\t"${contig_length} >>  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap
        
else
      echo "dnaA map found"

    #the most right alignment this shows the start of the gene
    #sort -k9 -n ${outputFolderName}/start_alignment_mapping/${header}.minimap

    start=$(sort -k9 -n -r ${outputFolderName}/start_alignment_mapping/${header}.minimap|head -1 |awk -F "\t" '{OFS="\t"}{print $9+$2-$4+5}')
        contig_length=$(sort -k9 -n -r  ${outputFolderName}/start_alignment_mapping/${header}.minimap|head -1 |cut -f 7)
        
        echo -e ${header}"\tbacterial_contig\t"${number_of_mappings}"\t"${orientation}"\t"${start}"\t"${contig_length} >>  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap
        
fi


done

##================================
##print information
##================================

#cat ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap
#cut -f 3  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap

```


### 1.3 summary contigs

 ==> Take home: contig originates from?
 With the circular contigs I would go into the circluarizse step. 

```{bash}
##===========================================
#summary stats before circularizing
##===========================================

echo "============================================================"
echo "summary stats before circularizing"
echo "============================================================"

echo -e "We will proceed start aligning following " ${BacContigs} " contigss..."
grep "^#"  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap 
grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{if($2=="bacterial_contig")print $0}'

```


## 2. show circlarity

Not incorporated yet. 

#### 2.1 map ends
```{bash}

###------------------------------------------------------
#extract start and end of read
###------------------------------------------------------
rm -r ${outputFolderName}/Start_end_overlap/
mkdir -p ${outputFolderName}/Start_end_overlap/{fastas,mapping}/

for header in $(grep ">" ${outputFolderName}/genomes/tmp_wide_all.fasta|sed 's/>//g')
do
echo -e ${header}
contig_length=$(sort -k9 -n -r  ${outputFolderName}/start_alignment_mapping/${header}.minimap|head -1 |cut -f 7)


#start extract

echo -e ${header}"\t1\t1000\t" > ${outputFolderName}/Start_end_overlap/start.bed
bedtools getfasta -fi ${outputFolderName}/genomes/contigs_split/${header}.fasta -bed ${outputFolderName}/Start_end_overlap/start.bed > ${outputFolderName}/Start_end_overlap/fastas/${header}_start.fasta

#end extract

echo -e ${header}| awk -F "\t" -v contigLength="$contig_length" '{OFS="\t"}{print $1,contigLength-1000,contigLength}' > ${outputFolderName}/Start_end_overlap/end.bed
bedtools getfasta -fi ${outputFolderName}/genomes/contigs_split/${header}.fasta -bed ${outputFolderName}/Start_end_overlap/end.bed > ${outputFolderName}/Start_end_overlap/fastas/${header}_end.fasta


done

###------------------------------------------------------
#map start and end
###------------------------------------------------------



for header in $(grep ">" ${outputFolderName}/genomes/tmp_wide_all.fasta|sed 's/>//g')
do

echo $header

##map dnaA genes to the individual references and remove non-mapping or low quality mapping reads (mapq>50) 
minimap2 ${outputFolderName}/Start_end_overlap/fastas/${header}_start.fasta ${outputFolderName}/Start_end_overlap/fastas/${header}_end.fasta |awk -F "\t" '{OFS="\t"}{if($12>50) print $0}'  > ${outputFolderName}/Start_end_overlap/mapping/${header}_mapping.paf

done

###------------------------------------------------------
#analysis
###------------------------------------------------------


echo -e "OverlapingContigEdges" > ${outputFolderName}/Start_end_overlap/tmp.analysis

for header in $(grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{print $1}')
do

echo $header

##check if there are overlapping contig edges identified in the mapping file
readCounts=$(wc -l ${outputFolderName}/Start_end_overlap/mapping/${header}_mapping.paf)

 
echo -e ${readCounts} | awk '{if ($1==0)	print "N" ; else 	print "Y"}' >> ${outputFolderName}/Start_end_overlap/tmp.analysis

done

#Merge with previous analysis
paste -d "\t" ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap ${outputFolderName}/Start_end_overlap/tmp.analysis >  ${outputFolderName}/Start_end_overlap/analysis_circularity_extended

cat  ${outputFolderName}/Start_end_overlap/analysis_circularity_extended

```
#### 2.3 align reads

The second approach to study if the contigs are circular is to look for reads that map on either side.
Herefore we have to divide into a long read or PE short read option. 
We can also reuse the start and end fasta's created in the previous chunk. 


##### 2.3.1 long reads

```{bash long_overlaps, eval=FALSE}
##==========================================================
#PE long reads
#should be easy
#1. merge the two ends divided by "NNNN"s
#2. map to the new constructs
#3. set limitation that reads must map more then 1400bp
##==========================================================

#---------------------
#1. merge the two ends divided by "NNNN"s
#---------------------

rm -r ${outputFolderName}/Start_end_readmapping/long_read/
mkdir -p ${outputFolderName}/Start_end_readmapping/long_read/{fastas,mapping}/

for header in $(grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{print $1}')
do
echo -e ${header}

#merge start and end divided by NNNNs

echo -e ">"${header}"_EndAndStart" > ${outputFolderName}/Start_end_readmapping/long_read/fastas/${header}_EndAndStart.fasta
grep ">" -v ${outputFolderName}/Start_end_overlap/fastas/${header}_end.fasta >> ${outputFolderName}/Start_end_readmapping/long_read/fastas/${header}_EndAndStart.fasta
echo -e "NNNNNNNNNN" >> ${outputFolderName}/Start_end_readmapping/long_read/fastas/${header}_EndAndStart.fasta
grep ">" -v ${outputFolderName}/Start_end_overlap/fastas/${header}_start.fasta >> ${outputFolderName}/Start_end_readmapping/long_read/fastas/${header}_EndAndStart.fasta


##make the assembly fit together nicely (60 nucleotides wide)
awk 'BEGIN{RS=">"}NR>1{sub("\n","\t"); gsub("\n",""); print RS$0}' ${outputFolderName}/Start_end_readmapping/long_read/fastas/${header}_EndAndStart.fasta |sed 's/\t/\n/g' |awk -v FS= '/^>/{print;next}{for (i=0;i<=NF/60;i++) {for (j=1;j<=60;j++) printf "%s", $(i*60 +j); print ""}}'  > ${outputFolderName}/Start_end_readmapping/long_read/fastas/${header}_EndAndStart_fitted.fasta

rm ${outputFolderName}/Start_end_readmapping/long_read/fastas/${header}_EndAndStart.fasta 
done


#---------------------
#2. map to the new constructs
#---------------------

for header in $(grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{print $1}')
do
echo -e ${header}


##map dnaA genes to the individual references and remove non-mapping or low quality mapping reads (mapq>50) 
minimap2 -x map-ont -t ${threads} ${outputFolderName}/Start_end_readmapping/long_read/fastas/${header}_EndAndStart_fitted.fasta ${longreads} |awk -F "\t" '{OFS="\t"}{if($12>50) print $0}' > ${outputFolderName}/Start_end_readmapping/long_read/mapping/${header}_mapping.paf


done


#---------------------
#3. set limitation that reads must map more then 1400bp
#---------------------
#here I can define the minimal number of overlapping reads
limitOverlaps=5

echo -e "OverlapingLongReads" > ${outputFolderName}/Start_end_readmapping/long_read/tmp.analysis

for header in $(grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{print $1}')
do
echo -e ${header}


awk -F "\t" '{OFS="\t"}{if($10>1400) print $0}' ${outputFolderName}/Start_end_readmapping/long_read/mapping/${header}_mapping.paf > ${outputFolderName}/Start_end_readmapping/long_read/mapping/${header}_mapping_overlaping_reads.paf
overlaps=$(wc -l ${outputFolderName}/Start_end_readmapping/long_read/mapping/${header}_mapping_overlaping_reads.paf |cut -d ' ' -f 1)


echo -e ${overlaps} | awk -v limitOverlapzz="$limitOverlaps" '{if ($1>limitOverlapzz)	print "Y" ; else 	print "N"}' >> ${outputFolderName}/Start_end_readmapping/long_read/tmp.analysis


done

#Merge with previous analysis
paste -d "\t" ${outputFolderName}/Start_end_overlap/analysis_circularity_extended ${outputFolderName}/Start_end_readmapping/long_read/tmp.analysis >  ${outputFolderName}/Start_end_readmapping/long_read/analysis_circularity_extended

cat  ${outputFolderName}/Start_end_readmapping/long_read/analysis_circularity_extended

```


##### 2.3.2 short reads

```{bash}
##==========================================================
#PE short reads
##==========================================================


#---------------------
#1. merge the two ends divided by "NNNN"s
#---------------------

rm -r ${outputFolderName}/Start_end_readmapping/short_read/
mkdir -p ${outputFolderName}/Start_end_readmapping/short_read/{fastas,mapping}/

for header in $(grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{print $1}')
do
echo -e ${header}

#merge start and end divided by NNNNs

echo -e ">"${header}"_EndAndStart" > ${outputFolderName}/Start_end_readmapping/short_read/fastas/${header}_EndAndStart.fasta
grep ">" -v ${outputFolderName}/Start_end_overlap/fastas/${header}_end.fasta >> ${outputFolderName}/Start_end_readmapping/short_read/fastas/${header}_EndAndStart.fasta
echo -e "NNNNNNNNNN" >> ${outputFolderName}/Start_end_readmapping/short_read/fastas/${header}_EndAndStart.fasta
grep ">" -v ${outputFolderName}/Start_end_overlap/fastas/${header}_start.fasta >> ${outputFolderName}/Start_end_readmapping/short_read/fastas/${header}_EndAndStart.fasta


##make the assembly fit together nicely (60 nucleotides wide)
awk 'BEGIN{RS=">"}NR>1{sub("\n","\t"); gsub("\n",""); print RS$0}' ${outputFolderName}/Start_end_readmapping/short_read/fastas/${header}_EndAndStart.fasta |sed 's/\t/\n/g' |awk -v FS= '/^>/{print;next}{for (i=0;i<=NF/60;i++) {for (j=1;j<=60;j++) printf "%s", $(i*60 +j); print ""}}'  > ${outputFolderName}/Start_end_readmapping/short_read/fastas/${header}_EndAndStart_fitted.fasta

rm ${outputFolderName}/Start_end_readmapping/short_read/fastas/${header}_EndAndStart.fasta 
done


#---------------------
#2. map to the new constructs
#---------------------

for header in $(grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{print $1}')
do
echo -e ${header}


#map dnaA genes to the individual references and remove non-mapping or low quality mapping reads (mapq>50) 
#minimap2 -x sr -t ${threads} ${outputFolderName}/Start_end_readmapping/short_read/fastas/${header}_EndAndStart_fitted.fasta ${shortreads_1} ${shortreads_2} |awk -F "\t" '{OFS="\t"}{if($12>50) print $0}' > ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping.paf


#minimap2 -ax sr -t ${threads} ${outputFolderName}/Start_end_readmapping/short_read/fastas/${header}_EndAndStart_fitted.fasta ${shortreads_1} ${shortreads_2} |samtools view -F 4 > ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping.sam

wc -l ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping.paf

done


#---------------------
#3. reads that map longer than xx and map on either side
#---------------------
#here I can define the minimal number of overlapping reads
limitOverlaps=5

echo -e "OverlapingShortReads" > ${outputFolderName}/Start_end_readmapping/short_read/tmp.analysis

for header in $(grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{print $1}')
do
echo -e ${header}



reads_mapping=$(awk '{if($8<990 && $9>1020 && $10 > 0.5*$2) print $0}'  ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping.paf |wc -l |cut -d ' ' -f 1)

Read_counts=$(wc -l  ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping.paf |cut -d ' ' -f 1)

echo -e ${header}" has in total "${reads_mapping}" supporting the ciruclarity with "${Read_counts}" mappig to the edges"


echo -e ${reads_mapping} | awk -v limitOverlapzz="$limitOverlaps" '{if ($1>limitOverlapzz)	print "Y" ; else 	print "N"}' >> ${outputFolderName}/Start_end_readmapping/short_read/tmp.analysis


done

#Merge with previous analysis
paste -d "\t" ${outputFolderName}/Start_end_readmapping/long_read/analysis_circularity_extended ${outputFolderName}/Start_end_readmapping/short_read/tmp.analysis >  ${outputFolderName}/Start_end_readmapping/short_read/analysis_circularity_extended

cat  ${outputFolderName}/Start_end_readmapping/short_read/analysis_circularity_extended

```


```{bash backup_short_overlaps_01, eval=FALSE}
#---------------------
#3. paired end reads that map on either side
#---------------------
#here I can define the minimal number of overlapping reads
limitOverlaps=5


for header in $(grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{print $1}')
do
echo -e ${header}

#wc -l ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping.paf


#loop through all paired reads

cut -f 1 ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping.paf|sort|uniq -c | sed -e 's/^[[:space:]]*//' |awk '{if($1==2)print $2}' > ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping_pairedEND.reads

#prim the counter and the reads
counter=0
reads=1

#read until we have found more then limitOverlaps read pairs 

until [ $counter -gt ${limitOverlaps} ]
    do
      #echo Counter: $counter

        readName=$(sed -n "${reads}p" ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping_pairedEND.reads)
        #extract paired end reads
      awk -v readNamez="$readName" '{if($1==readNamez)print $0}' ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping.paf > ${outputFolderName}/Start_end_readmapping/short_read/mapping/tmp.paf
  
      #check if first read maps bellow xx
      first_read=$(awk '{if($9<1011 && $10> 0.5*$2) print $0}' ${outputFolderName}/Start_end_readmapping/short_read/mapping/tmp.paf |wc -l |cut -d ' ' -f 1)
      #check if second read maps above xx
      second_read=$(awk '{if($9>1011 && $10>0.5*$2) print $0}' ${outputFolderName}/Start_end_readmapping/short_read/mapping/tmp.paf |wc -l |cut -d ' ' -f 1)

#first_read=1
#second_read=1
  if [[ "$first_read" == 1 && "$second_read" == 1 ]];
  
    then              
      echo  "Paired end read mapping number "${counter}
        ((counter++))

  else              

        echo "No Paired end read mapping "
        #Don't count

  fi  
  
  
        #next read
        ((reads++))

      done #readsss

echo -e ${header}" has in total "${counter}" supporting the ciruclarity after "${reads}" of" $(wc -l ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping_pairedEND.reads |cut -d ' ' -f 1) "read pairs checked"

done

```

```{bash backup_short_overlaps_02, eval=FALSE}




##-------------do parallel
###------define TASK


task(){ 
       #echo Counter: $counter

        readName=$(sed -n "${reads}p" ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping_pairedEND.reads)
        #extract paired end reads
      awk -v readNamez="$readName" '{if($1==readNamez)print $0}' ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping.paf > ${outputFolderName}/Start_end_readmapping/short_read/mapping/tmp.paf
  
      #check if first read maps bellow xx
      first_read=$(awk '{if($9<1011 && $10> 0.5*$2) print $0}' ${outputFolderName}/Start_end_readmapping/short_read/mapping/tmp.paf |wc -l |cut -d ' ' -f 1)
      #check if second read maps above xx
      second_read=$(awk '{if($9>1011 && $10>0.5*$2) print $0}' ${outputFolderName}/Start_end_readmapping/short_read/mapping/tmp.paf |wc -l |cut -d ' ' -f 1)

#first_read=1
#second_read=1
  if [[ "$first_read" == 1 && "$second_read" == 1 ]];
  
    then              
      echo  "Paired end read mapping number "${counter}
        ((counter++))

  else              

        echo "No Paired end read mapping "
        #Don't count

  fi  
  
  

}






###------Run parallel in batches
#---------------------
#3. paired end reads that map on either side
#---------------------
#here I can define the minimal number of overlapping reads
limitOverlaps=5
#number of parallel calculations
N=100


for header in $(grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{print $1}')
do
echo -e ${header}

#wc -l ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping.paf


#loop through all paired reads

cut -f 1 ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping.paf|sort|uniq -c | sed -e 's/^[[:space:]]*//' |awk '{if($1==2)print $2}' > ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping_pairedEND.reads

paired_end_read_counts=$($(wc -l ${outputFolderName}/Start_end_readmapping/short_read/mapping/${header}_mapping_pairedEND.reads |cut -d ' ' -f 1))


#prim the counter and the reads
counter=0
reads=1

#read until we have found more then limitOverlaps read pairs 

until [ $counter -gt ${limitOverlaps} || $reads -gt ${paired_end_read_counts}  ]
    do
      #echo Counter: $counter

    ##--------------run task in parallel

    ((i=i%N)); ((i++==0)) && wait
    task &

  
        #next read
        ((reads++))

      done #readsss
      

echo -e ${header}" has in total "${counter}" supporting the ciruclarity after "${reads}" of" ${paired_end_read_counts} "read pairs checked"


done

```


##### 2.3 final verdict

```{bash}

##-------------------------------------
#check if the contig can be circularized
#1. is it bacterial origin (contains dnaA)
#2. is it either end overlaping or do short or long reads map on either side
##-------------------------------------

echo -e "Circularizable" > ${outputFolderName}/Start_end_readmapping/tmp.circularizable

for contigName in $(grep "^#" -v  ${outputFolderName}/Start_end_readmapping/short_read/analysis_circularity_extended |awk -F "\t" '{OFS="\t"}{print $1}')
do
echo $contigName

awk -F "\t" -v contigNames="$contigName" '{OFS="\t"}{if($1==contigNames )print $0}' ${outputFolderName}/Start_end_readmapping/short_read/analysis_circularity_extended  |awk -F "\t" -v contigNames="$contigName" '{OFS="\t"}{if($2=="bacterial_contig"  && ($7=="Y"||$8=="Y"||$9=="Y"))print "Y"; else print "N"}' >> ${outputFolderName}/Start_end_readmapping/tmp.circularizable 


done

#Merge with previous analysis
paste -d "\t" ${outputFolderName}/Start_end_readmapping/short_read/analysis_circularity_extended ${outputFolderName}/Start_end_readmapping/tmp.circularizable  >  ${outputFolderName}/analysis_circularity_extended.log

cat  ${outputFolderName}/analysis_circularity_extended.log
```



## 3. Circleries

#### 3.1 Circleries contigs

use [fasta_shift](https://github.com/b-brankovics/fasta_tools).

```{bash Circleries, eval=FALSE}
##===========
##start align
##===========

 rm -r ${outputFolderName}/StartAlignedContigs/
 mkdir -p ${outputFolderName}/StartAlignedContigs/
 mkdir -p ${outputFolderName}/tmp/
 
#for contigName in $(grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{if($2=="bacterial_contig"    )print $1}')
  
#for contigName in $(grep "^#" -v  ${outputFolderName}/analysis_circularity_extended.log |awk -F "\t" '{OFS="\t"}{if($2=="bacterial_contig"  && ($7=="Y"||$8=="Y"||$9=="Y"))print $1}')

for contigName in $(grep "^#" -v  ${outputFolderName}/analysis_circularity_extended.log |awk -F "\t" '{OFS="\t"}{if($10=="Y")print $1}')
do

echo -e "contig name: \t\t" ${contigName}
 orientation=$(awk -F "\t" -v contigzz="$contigName" '{OFS="\t"}{if($1==contigzz)print $4}' ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap )
 contigStart=$(awk -F "\t" -v contigzz="$contigName" '{OFS="\t"}{if($1==contigzz)print $5}'   ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap )
 contigLength=$(awk -F "\t" -v contigzz="$contigName" '{OFS="\t"}{if($1==contigzz)print $6}'  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap )

  if [ $orientation == "+" ]
    then              
      echo "forward oriented and start align at:  "${contigStart}

      $fasta_shift_path -i ${outputFolderName}/genomes/contigs_split/${contigName}.fasta -p ${contigStart} > \
              ${outputFolderName}/StartAlignedContigs/${contigName}_startAligned.fasta
              
      sed -i '/^>/ s/$/_StartAligned/' ${outputFolderName}/StartAlignedContigs/${contigName}_startAligned.fasta 

  else              

        echo "reverse oriented and start align at:  "${contigStart}

      $fasta_shift_path -i ${outputFolderName}/genomes/contigs_split/${contigName}.fasta -p ${contigStart} > \
              ${outputFolderName}/tmp/${contigName}_startAligned_wrongOrientation.fasta
      
      revseq -sequence ${outputFolderName}/tmp/${contigName}_startAligned_wrongOrientation.fasta -outseq \
          ${outputFolderName}/StartAlignedContigs/${contigName}_startAligned.fasta -notag
      
      #add startaligned tag

    #  grep ">" ${outputFolderName}/StartAlignedContigs/${contigName}_startAligned.fasta
      sed -i '/^>/ s/$/_StartAligned/' ${outputFolderName}/StartAlignedContigs/${contigName}_startAligned.fasta 
    #  grep ">" ${outputFolderName}/StartAlignedContigs/${contigName}_startAligned.fasta


  fi  


done
```

#### 3.2 QC of Circleries 


```{bash QC_Circleries, eval=FALSE}
###-------------------QC if DNA is really at first position
  
echo -e "#contigName\tContigOrigin\tNumberOfdnaAmappings\tOrientationOfMapping\tStartOfTargetMapping\tContigLength" >  ${outputFolderName}/start_alignment_mapping/After_StartAlignment_contigs.minimap

for contigName in $(grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{if($2=="bacterial_contig")print $1}')
do

minimap2 ${outputFolderName}/StartAlignedContigs/${contigName}_startAligned.fasta  ${circleriesPATH}/05_startAlign_data/starting_genes.fasta |awk -F "\t" '{OFS="\t"}{if($12>50) print $0}'  > ${outputFolderName}/start_alignment_mapping/${header_short}_afterStartAlignment.minimap

sort -k10 -n -r ${outputFolderName}/start_alignment_mapping/${header_short}_afterStartAlignment.minimap |head -1


number_of_mappings=$(wc -l ${outputFolderName}/start_alignment_mapping/${header_short}_afterStartAlignment.minimap|cut -d ' ' -f 1)
orientation=$(sort -k10 -n -r ${outputFolderName}/start_alignment_mapping/${header_short}_afterStartAlignment.minimap|head -1 |cut -f 5)

  
if [ $number_of_mappings == "0" ]
then
        echo "no dnaA map found"
      
       echo -e ${header}"\tnon-bacterial_contig\t"${number_of_mappings}"\tNA\tNA\tNA" >>  ${outputFolderName}/start_alignment_mapping/After_StartAlignment_contigs.minimap
    
elif [ $orientation == "+" ]
then
           echo "Looks good!"

  start=$(sort -k8 -n ${outputFolderName}/start_alignment_mapping/${header_short}_afterStartAlignment.minimap|head -1 |awk -F "\t" '{OFS="\t"}{print $8-$3-5}')
        contig_length=$(sort -k8 -n ${outputFolderName}/start_alignment_mapping/${header_short}_afterStartAlignment.minimap|head -1 |cut -f 7)
        
        echo -e ${header}"\tbacterial_contig\t"${number_of_mappings}"\t"${orientation}"\t"${start}"\t"${contig_length} >>  ${outputFolderName}/start_alignment_mapping/After_StartAlignment_contigs.minimap
        
else

    start=$(sort -k9 -n -r ${outputFolderName}/start_alignment_mapping/${header_short}_afterStartAlignment.minimap|head -1 |awk -F "\t" '{OFS="\t"}{print $9+$2-$4+5}')
        contig_length=$(sort -k9 -n -r  ${outputFolderName}/start_alignment_mapping/${header_short}_afterStartAlignment.minimap|head -1 |cut -f 7)
        
        echo -e ${header}"\tbacterial_contig\t"${number_of_mappings}"\t"${orientation}"\t"${start}"\t"${contig_length} >>  ${outputFolderName}/start_alignment_mapping/After_StartAlignment_contigs.minimap
        
        echo "SOMETHING IS WRONG BECAUSE dnaA IS STILL ON THE REVERSE STRAND"
fi

done

```


#### 3.2 bring contigs together again

Here, I finally merge the contigs again. 

```{bash merge_Circleries, eval=FALSE}


grep "^#" -v  ${outputFolderName}/analysis_circularity_extended.log |awk -F "\t" '{OFS="\t"}{if($10=="Y")print $1}'

rm  ${outputFolderName}/${outName}.fasta
for contigName in $(grep ">" ${outputFolderName}/genomes/tmp_wide_all.fasta|sed 's/>//g')
do

circular=$(awk -F "\t" -v contigzz="$contigName" '{OFS="\t"}{if($1==contigzz)print $10} ' ${outputFolderName}/analysis_circularity_extended.log )


 if [ $circular == "Y" ];
    then              
     echo -e "Circularized contig name: \t\t" ${contigName}
     cat ${outputFolderName}/StartAlignedContigs/${contigName}_startAligned.fasta  >> ${outputFolderName}/${outName}.fasta

  else              

     echo -e "Non-Circularized contig name: \t\t" ${contigName}
     cat  ${outputFolderName}/genomes/${contigName}.fasta  >> ${outputFolderName}/${outName}.fasta


  fi  

done

#grep ">" ${outputFolderName}/${outName}.fasta

```


#### 3.3 Final_Info

Here, I finally merge the contigs again. 

```{bash finalInfo_Circleries, eval=FALSE}

echo "============================================================"
echo "Final Infos"
echo "============================================================"
here=$(pwd)
echo -e "Location of Startaligned contigs: \t\t"${here}/${outputFolderName}/${outName}".fasta"


numberContigs=$(grep "^#" -c ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap)
BacContigs=$(grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{if($2=="bacterial_contig")print $0}'|wc -l)
NonBacContigs=$(grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{if($2!="bacterial_contig")print $0}' |wc -l)

echo -e "Total number of contigs: \t\t"${numberContigs}
echo -e "Bacterial contigs: \t\t"${BacContigs}
#grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{if($2=="bacterial_contig")print $0}'
echo -e "Non-Bacterial contigs: \t\t"${NonBacContigs}
#grep "^#" -v  ${outputFolderName}/start_alignment_mapping/StartAlignment_contigs.minimap |awk -F "\t" '{OFS="\t"}{if($2!="bacterial_contig")print $0}'


echo -e "The location of dnaA on the " ${BacContigs} " Bacterial contigs..."
grep "^#"  ${outputFolderName}/start_alignment_mapping/After_StartAlignment_contigs.minimap
grep "^#" -v  ${outputFolderName}/start_alignment_mapping/After_StartAlignment_contigs.minimap|awk -F "\t" '{OFS="\t"}{if($2=="bacterial_contig")print $0}'


echo -e "Remember the contigs should still be polished now..."

```


